#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../API.h"

/* ============================== API.h ==============================
From "API.h":

typedef struct Sequential {	
	void* data;
	
	void  (*destructor) (Sequential* container);
	
	void (*begin) (Sequential* container, Iterator pointer);
	void (*end) (Sequential* container, Iterator pointer);
	void (*next) (Sequential* container, Iterator pointer);
	void (*prev) (Sequential* container, Iterator pointer);
	
	void* (*get) (Sequential* container, Iterator pointer);	
	void  (*insert) (Sequential* container, Iterator index, void* content);
	void  (*resize) (Sequential* container, int size);
	void  (*swap) (Sequential* container, Iterator index1, Iterator index2);

	Iterator (*iterator_init) (struct Sequential* container);
	void (*iterator_destroy) (Iterator pointer);
} Sequential;

Sequential* list_create (int size, void** initial_content);
================================================================== */

typedef struct cell cell;
	struct cell {
		void* data;
		cell* prev;
		cell* next;
	}typedef cell;

struct list {
	cell* front;
	cell* back;
	int size;
}typedef list;

list* converter(Sequential* this_list) return (list*)(this_list->data);

// ========================== FUNCTIONS ==========================

void destroy(Sequential*);

void begin(Sequential*, Iterator pointer);
void end(Sequential*, Iterator pointer);
void next(Sequential*, Iterator pointer);
void prev(Sequential*, Iterator pointer);

void set(Sequential*, Iterator pointer, void* content);
void* get(Sequential*, Iterator pointer);
void insert(Sequential*, Iterator index, void* content);
void swap(Sequential*, Iterator index1, Iterator index2);

Iterator iterator_init(struct Sequential* container);
void iterator_destroy(Iterator pointer);

// ========================== LIST_CREATE ==========================

Sequential* list_create(int size, void** initial_content) {
	Sequential* this_list = malloc(sizeof(Sequential));
	this_list->data = (void*)malloc(sizeof(list));

	this_list->destroy = (destroy);

	this_list->begin = begin;
	this_list->end = end;
	this_list->next = next;
	this_list->prev = prev;

	this_list->set = set;
	this_list->get = (get);
	this_list->insert = (insert);
	this_list->swap = (swap);

	this_list->iterator_init = iterator_init;
	this_list->iterator_destroy = iterator_destroy;

	list* p_list = listof(this_list);
	p_list->back = p_list->front;
	p_list->size = 0;
	printf("this_list->front - %p\nthis_list->back - %p\n", p_list->front, p_list->back);

	void* p;
	int i = 0;
	for (i = 0; i < size; i++) {
		end(this_list, p);
		set(this_list, p, initial_content[i]);
	}

	return this_list;
}

// ========================= ITERATOR_INIT ===========================

Iterator iterator_init(struct Sequential* this_list) {
	void* p = ((list*)(this_list))->front;
	return p;
}

// ======================== ITERATOR_DESTROY =========================

void iterator_destroy(Iterator p) {
	if (p) free(p);
}

// ============================== BEGIN ==============================

void begin(Sequential* this_list, Iterator p) {
	p = (void*)(((list*)(this_list->data))->front);
}

// =============================== END ===============================

void end(Sequential* this_list, Iterator p) {
	cell* last = ((list*)(this_list->data))->back;
	cell* tmp = (cell*)malloc(sizeof(cell));
    if (tmp == NULL) exit(3);

    tmp->next = NULL;
    tmp->prev = last;

	p = tmp;
}

// =============================== SET ===============================

void set(Sequential* container, Iterator p, void* content) {
	((cell*)p)->data = content;	
}

// ============================== NEXT ==============================

void next(Sequential* container, Iterator p) {
	if (((cell*)p)->next) p = ((cell*)p)->next;
}

// ============================== PREV ==============================

void prev(Sequential* container, Iterator p) {
	if (((cell*)p)->prev) p = ((cell*)p)->prev;
}

// ============================== GET ==============================

void* get(Sequential* this_list, Iterator p) {
	return ((cell*)p)->data;
}
